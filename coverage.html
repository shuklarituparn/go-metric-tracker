
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/shuklarituparn/go-metric-tracker/cmd/agent/main.go (0.0%)</option>
				
				<option value="file1">github.com/shuklarituparn/go-metric-tracker/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">github.com/shuklarituparn/go-metric-tracker/internal/handler/healthcheck.go (0.0%)</option>
				
				<option value="file3">github.com/shuklarituparn/go-metric-tracker/internal/handler/metric_handler.go (57.9%)</option>
				
				<option value="file4">github.com/shuklarituparn/go-metric-tracker/internal/model/metrics.go (0.0%)</option>
				
				<option value="file5">github.com/shuklarituparn/go-metric-tracker/internal/repository/storage.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

func main() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"
        "net/http"

        "github.com/shuklarituparn/go-metric-tracker/internal/handler"
        "github.com/shuklarituparn/go-metric-tracker/internal/repository"
)

func main() <span class="cov0" title="0">{

        storage := repository.NewMemStorage()
        metricsHandler := handler.NewMetricHandler(storage)
        healthHandler := handler.NewHealthHandler(storage)

        mux := http.NewServeMux()
        mux.Handle("/update/", metricsHandler)

        debugHandler := handler.NewDebugHandler(storage)
        mux.Handle("/debug", debugHandler)
        mux.Handle("/health", healthHandler)

        addr := "localhost:8080"
        log.Printf("Starting metrics server on %s", addr)
        log.Printf("Update metrics: POST http://%s/update/&lt;type&gt;/&lt;name&gt;/&lt;value&gt;", addr)
        log.Printf("View metrics: GET http://%s/debug", addr)

        if err := http.ListenAndServe(addr, mux); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handler

import (
        "encoding/json"
        "log"
        "net/http"
        "time"

        "github.com/shuklarituparn/go-metric-tracker/internal/repository"
)

type HealthStatus struct {
        Status    string            `json:"status"`
        Timestamp string            `json:"timestamp"`
        Uptime    string            `json:"uptime"`
        Checks    map[string]string `json:"checks,omitempty"`
}

type HealthHandler struct {
        storage   repository.Storage
        startTime time.Time
}

func NewHealthHandler(storage repository.Storage) *HealthHandler <span class="cov0" title="0">{
        return &amp;HealthHandler{
                storage:   storage,
                startTime: time.Now(),
        }
}</span>

func (h *HealthHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">uptime := time.Since(h.startTime)

        storageHealth := "healthy"
        if h.storage == nil </span><span class="cov0" title="0">{
                storageHealth = "unhealthy"
        }</span> else<span class="cov0" title="0"> {
                metrics := h.storage.GetAllMetrics()
                if metrics == nil </span><span class="cov0" title="0">{
                        storageHealth = "degraded"
                }</span>
        }

        <span class="cov0" title="0">overallStatus := "healthy"
        if storageHealth != "healthy" </span><span class="cov0" title="0">{
                overallStatus = "unhealthy"
        }</span>

        <span class="cov0" title="0">status := HealthStatus{
                Status:    overallStatus,
                Timestamp: time.Now().Format(time.RFC3339),
                Uptime:    uptime.String(),
                Checks: map[string]string{
                        "storage": storageHealth,
                },
        }

        statusCode := http.StatusOK
        if overallStatus == "unhealthy" </span><span class="cov0" title="0">{
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        if err := json.NewEncoder(w).Encode(status); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to encode JSON response: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "fmt"
        "log"
        "net/http"
        "strconv"
        "strings"

        models "github.com/shuklarituparn/go-metric-tracker/internal/model"
        "github.com/shuklarituparn/go-metric-tracker/internal/repository"
)

type MetricsHandler struct {
        storage repository.Storage
}
type DebugHandler struct {
        storage repository.Storage
}

func NewMetricHandler(storage repository.Storage) *MetricsHandler <span class="cov8" title="1">{
        return &amp;MetricsHandler{
                storage: storage,
        }
}</span>

func (h *MetricsHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Printf("Received request: %s %s", r.Method, r.URL.Path)
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">requestURL := strings.TrimPrefix(r.URL.Path, "/")
        parts := strings.Split(requestURL, "/")
        log.Printf("Path parts: %v (length: %d)", parts, len(parts))
        if len(parts) &lt; 3 || parts[0] != "update" </span><span class="cov0" title="0">{
                http.Error(w, "Not found", http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">if len(parts) &lt; 3 || parts[2] == "" </span><span class="cov8" title="1">{
                http.Error(w, "Metric name required", http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                http.Error(w, "Bad request", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">typeOfMetric := parts[1]
        metricName := parts[2]
        valueMetric := parts[3]

        switch typeOfMetric </span>{
        case models.Gauge:<span class="cov8" title="1">
                value, err := strconv.ParseFloat(valueMetric, 64)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid gauge value", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if err := h.storage.UpdateGauge(metricName, value); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal server error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">w.Header().Set("Content-type", "text/plain")
                w.WriteHeader(http.StatusOK)</span>
        case models.Counter:<span class="cov8" title="1">
                value, err := strconv.ParseInt(valueMetric, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid counter value", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if err := h.storage.UpdateCounter(metricName, value); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal server error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">w.Header().Set("Content-type", "text/plain")
                w.WriteHeader(http.StatusOK)</span>
        default:<span class="cov8" title="1">
                http.Error(w, "Invalid metric type", http.StatusBadRequest)
                return</span>
        }

}

func NewDebugHandler(storage repository.Storage) *DebugHandler <span class="cov0" title="0">{
        return &amp;DebugHandler{
                storage: storage,
        }
}</span>

func (h *DebugHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">metrics := h.storage.GetAllMetrics()
        w.Header().Set("Content-Type", "text/plain; charset=utf-8")

        if len(metrics) == 0 </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintln(w, "No metrics stored yet"); err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to write response: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">for _, metric := range metrics </span><span class="cov0" title="0">{
                switch metric.MType </span>{
                case models.Gauge:<span class="cov0" title="0">
                        if _, err := fmt.Fprintf(w, "%s (gauge): %v\n", metric.ID, *metric.Value); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to write response: %v", err)
                        }</span>
                case models.Counter:<span class="cov0" title="0">
                        if _, err := fmt.Fprintf(w, "%s (counter): %v\n", metric.ID, *metric.Delta); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to write response: %v", err)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

const (
        Counter = "counter"
        Gauge   = "gauge"
)

// NOTE: Не усложняем пример, вводя иерархическую вложенность структур.
// Органичиваясь плоской моделью.
// Delta и Value объявлены через указатели,
// что бы отличать значение "0", от не заданного значения
// и соответственно не кодировать в структуру.
type Metrics struct {
        ID    string   `json:"id"`
        MType string   `json:"type"`
        Delta *int64   `json:"delta,omitempty"`
        Value *float64 `json:"value,omitempty"`
        Hash  string   `json:"hash,omitempty"`
}

func (M *Metrics) IsValid() bool <span class="cov0" title="0">{
        if M.ID == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">switch M.MType </span>{
        case Gauge:<span class="cov0" title="0">
                return M.Value != nil &amp;&amp; M.Delta != nil</span>
        case Counter:<span class="cov0" title="0">
                return M.Delta != nil &amp;&amp; M.Value != nil</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (M *Metrics) GetGuageValue() (float64, bool) <span class="cov0" title="0">{
        if M.MType != Gauge || M.Value == nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">return *M.Value, true</span>
}

func (M *Metrics) GetCounterValue() (int64, bool) <span class="cov0" title="0">{
        if M.MType != Counter || M.Delta == nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">return *M.Delta, true</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package repository

import (
        "fmt"
        "sync"

        models "github.com/shuklarituparn/go-metric-tracker/internal/model"
)

type Storage interface {
        UpdateGauge(name string, value float64) error
        UpdateCounter(name string, value int64) error
        GetCounter(name string) (int64, bool)
        GetGauge(name string) (float64, bool)
        GetAllMetrics() []models.Metrics
        GetMetric(name string) (*models.Metrics, bool)
}

type MemStorage struct {
        mu       sync.RWMutex
        gauges   map[string]float64
        counters map[string]int64
}

func NewMemStorage() *MemStorage <span class="cov0" title="0">{
        return &amp;MemStorage{
                gauges:   make(map[string]float64),
                counters: make(map[string]int64),
        }
}</span>

func (ms *MemStorage) UpdateGauge(name string, value float64) error <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("error: gauge metric name cannot be empty")
        }</span>
        <span class="cov0" title="0">ms.mu.Lock()
        defer ms.mu.Unlock()
        ms.gauges[name] = value
        return nil</span>
}

func (ms *MemStorage) UpdateCounter(name string, value int64) error <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("error: counter metric name cannot be empty")
        }</span>
        <span class="cov0" title="0">ms.mu.Lock()
        defer ms.mu.Unlock()
        ms.counters[name] += value
        return nil</span>
}

func (ms *MemStorage) GetCounter(name string) (int64, bool) <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">ms.mu.RLock()
        defer ms.mu.RUnlock()
        value, ok := ms.counters[name]
        return value, ok</span>
}

func (ms *MemStorage) GetGauge(name string) (float64, bool) <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">ms.mu.RLock()
        defer ms.mu.RUnlock()
        value, ok := ms.gauges[name]
        return value, ok</span>
}

func (ms *MemStorage) GetMetric(name string) (*models.Metrics, bool) <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">ms.mu.RLock()
        defer ms.mu.RUnlock()

        if value, ok := ms.gauges[name]; ok </span><span class="cov0" title="0">{
                return &amp;models.Metrics{
                        ID:    name,
                        MType: models.Gauge,
                        Value: &amp;value,
                }, true
        }</span>

        <span class="cov0" title="0">if value, ok := ms.counters[name]; ok </span><span class="cov0" title="0">{
                return &amp;models.Metrics{
                        ID:    name,
                        MType: models.Counter,
                        Delta: &amp;value,
                }, true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func (ms *MemStorage) GetAllMetrics() []models.Metrics <span class="cov0" title="0">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        var metric []models.Metrics

        for name, value := range ms.gauges </span><span class="cov0" title="0">{
                v := value
                metric = append(metric, models.Metrics{
                        ID:    name,
                        Value: &amp;v,
                        MType: models.Gauge,
                })
        }</span>

        <span class="cov0" title="0">for name, value := range ms.counters </span><span class="cov0" title="0">{
                delta := value
                metric = append(metric, models.Metrics{
                        ID:    name,
                        MType: models.Counter,
                        Delta: &amp;delta,
                })
        }</span>
        <span class="cov0" title="0">return metric</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
